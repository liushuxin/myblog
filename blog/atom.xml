<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://liushuxin.github.io/myblog/blog</id>
    <title>述新的技术博客 Blog</title>
    <updated>2023-09-07T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://liushuxin.github.io/myblog/blog"/>
    <subtitle>述新的技术博客 Blog</subtitle>
    <icon>https://liushuxin.github.io/myblog/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[MACOS 中通过命令来控制电脑交互]]></title>
        <id>MACOS</id>
        <link href="https://liushuxin.github.io/myblog/blog/MACOS"/>
        <updated>2023-09-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Applescript]]></summary>
        <content type="html"><![CDATA[<h4>Applescript</h4><p>是苹果公司开发的一种脚本语言，可以用来控制运行于Mac OS上的程序，也可以写成独立运行的Applet</p><p>可以用于控制多个项目一键启动，配合iTrem2 效果可以说是比较不错的</p><pre><code class="language-shell">set project1 to &quot; cd ~/project1&quot;
set project2 to &quot;cd ~/project2&quot;
set project3 to &quot;cd ~/project3&quot;
set project4 to &quot;cd ~/project4&quot;
#applescript

tell application &quot;iTerm&quot;
    activate
end tell

tell application &quot;System Events&quot;

    tell process &quot;iTerm&quot;

        # project1 1
        keystroke project1
        delay 1 -- 延时一秒后执行
        key code 36
        delay 1

        keystroke &quot;pnpm start&quot;
        delay 1 -- 延时一秒后执行
        key code 36
        delay 1


        # project2 2
        key code 2 using {command down}
        delay 1

        keystroke project2
        delay 1 -- 延时一秒后执行
        key code 36
    delay 1

        keystroke &quot;pnpm start&quot;
        delay 1
        key code 36
        delay 1



        # project3
        key code 2 using {command down}
        delay 1

        keystroke project3
        delay 1
        key code 36
        delay 1

        keystroke &quot;pnpm start:debug&quot;
        delay 1 -- 延时一秒后执行
        key code 36
        delay 1

        # project4
        key code 2 using {command down}
        delay 1
        keystroke project4
        delay 1
        key code 36
        delay 1

        keystroke &quot;npm run start:saasstg&quot;
        delay 1 -- 延时一秒后执行
        key code 36
        delay 1
    end tell

end tell
</code></pre>]]></content>
        <author>
            <name>刘述新</name>
            <uri>https://github.com/endiliey</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[移动端网页调试相关技巧]]></title>
        <id>移动端网页调试相关技巧</id>
        <link href="https://liushuxin.github.io/myblog/blog/2022/01/03/http-capture"/>
        <updated>2022-01-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[1、如何进行移动端开发]]></summary>
        <content type="html"><![CDATA[<h2>1、如何进行移动端开发</h2><h3>真机调试</h3><p> <!-- --> <!-- -->做移动开发的时候大多数要跟手机界面打交道，也就是说，你只能在电脑上开发写代码，最终的效果确是在另一个终端虽然各种浏览器为开发者提供了很多模拟手机设备的功能，这些功能总体来说基本可以满足我们对于调试移动设备的需求，但是模拟终究是模拟，无法完全还原场景。所以，必须在想办法在真实的机子上测试我们的代码最终的执行效果。办法当然是有的，下面是露珠在开发过程中用到的若干真机调试方法：</p><h4>Chrome 真机调试</h4><p> <!-- --> <!-- -->chrome 必须有硬件的接触，
首先确保手机上和 PC 机上装有最新版本的 chrome 浏览器，然后将数据线将两台设备连接起来。在 PC 机上打开 chorme，输入 chrome://inspect,
于是你就可以看到自己的设备和打开的网页了:
<img src="./mobiledevtool.png" alt="调试界面"/></p><p> <!-- --> <!-- --> 设备网址下出现 inspect、reload、close 等选项，点击 inspect 会弹出一个窗口，阁下就可以在窗口中愉快地去调试了。
<img src="./mobilemock.png" alt="模拟界面"/></p><p>Chrome 手机调试工具优点：</p><p>在熟悉的开发模式下调试，操作比较简单。个人觉得 UC 在这方面胜过 chrome。可以跨平台，在 ios 上也可以用。</p><p>Chrome 手机调试工具缺点：</p><p>有目共睹，比起 UC 来，它步骤比较繁琐，不能 wifi 调试，必须指定手机和 PC 浏览器的类型（都是 chrome），这种模式无法调试微信或者其他 app 内置浏览器。</p><h4>Safari</h4><p>手机端：设置 → Safari → 高级 → Web 检查器 → 开
mac 端：Safari → 偏好设置 → 高级 → 在菜单栏中显示“开发”菜单
在 OS X 中启动 Safari 之后，以 USB 电缆正常接入 iOS 设备，并在此移动设备上启动 Safari。此时点击计算机上的 Safari 菜单中的“开发”，可以看到有 iOS 设备的名称显示，其子菜单项即为移动设备上 Safari 的所有标签页，点击任意一个开始调试。
苹果系列优点：</p><p>便捷，简单，高端大气上档次，可以调试外壳包裹的浏览器如微信。</p><p>苹果系列缺点：</p><p>设备限严重依赖其公司产品。</p>]]></content>
        <author>
            <name>刘述新</name>
            <uri>https://github.com/endiliey</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[从 0 实现一个前端监控 SDK]]></title>
        <id>AJAX</id>
        <link href="https://liushuxin.github.io/myblog/blog/AJAX"/>
        <updated>2021-12-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Docusaurus Plushie]]></summary>
        <author>
            <name>刘述新</name>
            <uri>https://github.com/endiliey</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[实现一个显示隐藏动画组件]]></title>
        <id>welcome</id>
        <link href="https://liushuxin.github.io/myblog/blog/welcome"/>
        <updated>2021-08-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Hello 大家好，今天给大家带来的文章是关于如何封装一个对不定高度的内容，显示隐藏的 react 动画组件]]></summary>
        <content type="html"><![CDATA[<p>Hello 大家好，今天给大家带来的文章是关于如何封装一个对不定高度的内容，显示隐藏的 react 动画组件</p><pre><code class="language-javascript">import React, { FC, useRef, useEffect, useState, CSSProperties } from &#x27;react&#x27;;
import ResizeObserver from &#x27;resize-observer-polyfill&#x27;;
import { Transition } from &#x27;react-transition-group&#x27;;
import type { Property } from &#x27;csstype&#x27;;
import { debounce } from &#x27;lodash&#x27;;
/**
 *
 * @returns 动画版显示隐藏组件
 */
interface AnimationShowProps {
  // default 300ms
  duration?: number;
  // whether visible
  visible: boolean;
  timingFunction?: Property.AnimationTimingFunction;
  style?: CSSProperties;
}
const resize = (setConHeight: () =&gt; void) =&gt; debounce(setConHeight, 300);

const AnimationShow: FC&lt;AnimationShowProps&gt; = ({
  duration = 300,
  timingFunction = &#x27;linear&#x27;,
  visible,
  children,
  style,
}) =&gt; {
  const [height, setHeight] = useState(0);
  const divRef = useRef&lt;HTMLDivElement&gt;(null);
  useEffect(() =&gt; {
    // listen container resize
    const setConHeight = (): void =&gt; {
      const clientRect = divRef.current?.getBoundingClientRect();
      if (clientRect) {
        setHeight(clientRect ? clientRect.height : 0);
      }
    };

    const resizeObserver = new ResizeObserver(resize(setConHeight));

    resizeObserver.observe(divRef.current as HTMLDivElement);

    return function cleanup() {
      resizeObserver.disconnect();
    };
  }, []);

  //css transition

  const defaultStyle = {
    transition: `height ${duration}ms ${timingFunction}`,
    height: 0,
    overflow: &#x27;hidden&#x27;,
  };

  const transitionStyles = {
    entering: {
      height,
    },
    entered: {
      height,
    },
    exiting: { height: 0 },
    exited: { height: 0 },
  };
  // css transition
  return (
    &lt;Transition in={visible} timeout={duration}&gt;
      {(state) =&gt; (
        &lt;div
          style={{
            ...style,
            ...defaultStyle,
            ...transitionStyles[state],
          }}
        &gt;
          &lt;div ref={divRef} style={{ overflow: &#x27;hidden&#x27; }}&gt;
            {children}
          &lt;/div&gt;
        &lt;/div&gt;
      )}
    &lt;/Transition&gt;
  );
};

export default AnimationShow;

</code></pre>]]></content>
        <author>
            <name>刘述新</name>
            <uri>https://github.com/endiliey</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[大文件分片下载与上传]]></title>
        <id>mdx-blog-post</id>
        <link href="https://liushuxin.github.io/myblog/blog/mdx-blog-post"/>
        <updated>2021-08-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Blog posts support Docusaurus Markdown features, such as MDX.]]></summary>
        <content type="html"><![CDATA[<p>Blog posts support <a href="https://docusaurus.io/docs/markdown-features">Docusaurus Markdown features</a>, such as <a href="https://mdxjs.com/">MDX</a>.</p><p>:::tip</p><p>:::</p>]]></content>
        <author>
            <name>Sébastien Lorber</name>
            <uri>https://sebastienlorber.com</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[图片的按需加载&列表按需加载]]></title>
        <id>long-blog-post</id>
        <link href="https://liushuxin.github.io/myblog/blog/long-blog-post"/>
        <updated>2021-05-29T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-javascript">import React, { FC, useRef, useEffect, useState, CSSProperties } from &#x27;react&#x27;;
import ResizeObserver from &#x27;resize-observer-polyfill&#x27;;
import { Transition } from &#x27;react-transition-group&#x27;;
import type { Property } from &#x27;csstype&#x27;;
import { debounce } from &#x27;lodash&#x27;;
/**
 *
 * @returns 动画版显示隐藏组件
 */
interface AnimationShowProps {
  // default 300ms
  duration?: number;
  // whether visible
  visible: boolean;
  timingFunction?: Property.AnimationTimingFunction;
  style?: CSSProperties;
}
const resize = (setConHeight: () =&gt; void) =&gt; debounce(setConHeight, 300);

const AnimationShow: FC&lt;AnimationShowProps&gt; = ({
  duration = 300,
  timingFunction = &#x27;linear&#x27;,
  visible,
  children,
  style,
}) =&gt; {
  const [height, setHeight] = useState(0);
  const divRef = useRef&lt;HTMLDivElement&gt;(null);
  useEffect(() =&gt; {
    // listen container resize
    const setConHeight = (): void =&gt; {
      const clientRect = divRef.current?.getBoundingClientRect();
      if (clientRect) {
        setHeight(clientRect ? clientRect.height : 0);
      }
    };

    const resizeObserver = new ResizeObserver(resize(setConHeight));

    resizeObserver.observe(divRef.current as HTMLDivElement);

    return function cleanup() {
      resizeObserver.disconnect();
    };
  }, []);

  //css transition

  const defaultStyle = {
    transition: `height ${duration}ms ${timingFunction}`,
    height: 0,
    overflow: &#x27;hidden&#x27;,
  };

  const transitionStyles = {
    entering: {
      height,
    },
    entered: {
      height,
    },
    exiting: { height: 0 },
    exited: { height: 0 },
  };
  // css transition
  return (
    &lt;Transition in={visible} timeout={duration}&gt;
      {(state) =&gt; (
        &lt;div
          style={{
            ...style,
            ...defaultStyle,
            ...transitionStyles[state],
          }}
        &gt;
          &lt;div ref={divRef} style={{ overflow: &#x27;hidden&#x27; }}&gt;
            {children}
          &lt;/div&gt;
        &lt;/div&gt;
      )}
    &lt;/Transition&gt;
  );
};

export default AnimationShow;

</code></pre>]]></content>
        <author>
            <name>刘述新</name>
            <uri>https://github.com/endiliey</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端理解的登录与鉴权]]></title>
        <id>JQ</id>
        <link href="https://liushuxin.github.io/myblog/blog/JQ"/>
        <updated>2021-01-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[hello 小伙伴们，今天给大家带来的是关于，登录-鉴权相关知识，SSO OATH2 JWT, BA 认证]]></summary>
        <content type="html"><![CDATA[<p>hello 小伙伴们，今天给大家带来的是关于，登录-鉴权相关知识，SSO OATH2 JWT, BA 认证</p>]]></content>
        <author>
            <name>刘述新</name>
            <uri>https://github.com/endiliey</uri>
        </author>
    </entry>
</feed>